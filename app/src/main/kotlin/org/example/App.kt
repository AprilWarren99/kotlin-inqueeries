/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import io.ktor.http.HttpStatusCode
import io.ktor.server.application.install
import org.example.dbHandler.Handler

import io.ktor.server.netty.*
import io.ktor.server.routing.*
import io.ktor.server.engine.*
import io.ktor.server.response.*
import io.ktor.server.html.respondHtml
import io.ktor.server.htmx.hx
import io.ktor.server.http.content.staticResources
import io.ktor.server.plugins.statuspages.StatusPages
import io.ktor.server.request.path
import io.ktor.server.request.receiveParameters
import io.ktor.utils.io.ExperimentalKtorApi
import kotlinx.html.*
import org.example.dataClasses.AccessibilityInformation
import org.example.dataClasses.Categories


import org.example.dataClasses.Contact
import org.example.dataClasses.Organization
import org.example.htmx.pages.allOrganizationsPage
import org.example.htmx.pages.updateOrganizationPage
import org.example.model.AccessibilityInformationTable
import org.example.model.CategoriesTable

import org.jetbrains.exposed.v1.jdbc.selectAll
import org.jetbrains.exposed.v1.jdbc.transactions.transaction

import org.example.model.ContactTable
import org.example.model.OrganizationTable
import org.jetbrains.exposed.v1.core.SortOrder
import org.jetbrains.exposed.v1.core.eq
import org.jetbrains.exposed.v1.core.leftJoin
import org.jetbrains.exposed.v1.jdbc.select
import org.jetbrains.exposed.v1.jdbc.update
import java.time.format.DateTimeFormatter
import kotlin.reflect.typeOf

@OptIn(ExperimentalKtorApi::class)
fun main() {
    // Init the database so the model objects can be used
    val dbHandler = Handler(true)
    val baseurl = "http://localhost:8081"

    embeddedServer(Netty, 8081) {

        install(StatusPages) {
            exception<Throwable> { call, cause ->
                call.application.environment.log.error("Request failed", cause)
                call.respondText("Something went wrong\n$cause")
            }
        }


        routing {
            staticResources("/static", "static")

            get("/all") {
                val contacts = mutableListOf<Map<String, String?>>()
                val organizations = mutableListOf<Map<String, String?>>()
                val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")

                transaction {
                    OrganizationTable.selectAll().orderBy(OrganizationTable.id to SortOrder.ASC).forEach {
                        val lastUpdate = it[OrganizationTable.lastUpdate]
                        val formattedLastUpdate = lastUpdate.format(formatter) ?: "N/A"  // Format the lastUpdate or default to "N/A"


                        organizations.add(
                            mapOf(
                                "id" to it[OrganizationTable.id].toString(),
                                "name" to it[OrganizationTable.name],
                                "email" to it[OrganizationTable.email],
                                "streetAddress" to it[OrganizationTable.streetAddress],
                                "description" to it[OrganizationTable.description],
                                "city" to it[OrganizationTable.city],
                                "phoneNumber" to it[OrganizationTable.phoneNumber],
                                "province" to it[OrganizationTable.province],
                                "socialMedia" to it[OrganizationTable.socialMedia],
                                "website" to it[OrganizationTable.website],
                                "queerOwned" to it[OrganizationTable.queerOwned].toString(),
                                "queerInclusive" to it[OrganizationTable.queerInclusive].toString(),
                                "accessibilityID" to it[OrganizationTable.accessibilityInformation].toString(),
                                "categoryID" to it[OrganizationTable.categoryInformation].toString(),
                                "lastUpdate" to formattedLastUpdate
                            )
                        )
                    }
                }
                call.respondHtml { allOrganizationsPage(organizations,
                    call.request.path()) }

                return@get
            }
            get("/update/{orgID}") {

                try {
                    val queryID = call.parameters["orgID"]?.toInt() ?: -1
                    val contactInfo: MutableList<Contact> = mutableListOf()
                    var organizationInfo: Organization? = null
                    var accessibilityInfo: AccessibilityInformation? = null
                    var categories: Categories? = null

                    if (queryID == -1){
                        call.respondText { "Invalid query ID" }
                        return@get
                    }

                    transaction {
                        organizationInfo = OrganizationTable
                            .selectAll()
                            .where { OrganizationTable.id eq queryID }
                            .map { Organization.fromRow(it) }
                            .firstOrNull()

                        ContactTable.selectAll()
                            .where { ContactTable.organizationID eq queryID }
                            .forEach { contact ->
                                try {
                                    val contactFromRow = Contact.fromRow(contact)
                                    contactInfo.add(contactFromRow)
                                } catch (e: Exception) {
                                    println("Error in Contact.fromRow: ${e.message}")
                                }
                            }

                        accessibilityInfo = AccessibilityInformationTable
                            .leftJoin(OrganizationTable,
                                { AccessibilityInformationTable.id },
                                { OrganizationTable.accessibilityInformation })
                            .selectAll()
                            .where{ OrganizationTable.id eq queryID }
                            .map{ AccessibilityInformation.fromRow(it) }
                            .firstOrNull()

                        categories = CategoriesTable
                            .leftJoin(OrganizationTable,
                                { CategoriesTable.id },
                                { OrganizationTable.categoryInformation })
                            .selectAll()
                            .where{ OrganizationTable.id eq queryID }
                            .map{ Categories.fromRow(it) }
                            .firstOrNull()
                    }
                        call.respondHtml {
                            updateOrganizationPage(
                                organizationInfo as Organization,
                                contacts = contactInfo,
                                path = call.request.path(),
                                accessInfo = accessibilityInfo as AccessibilityInformation,
                                categoriesInfo = categories as Categories
                            )
                        }
                } catch (e: Exception) {
                    println("Error: ${e.message}")
                    call.respondText { "An error occurred: ${e.message}" }
                }
            }
            hx.post("/update/{orgID}"){
                val params = call.receiveParameters()
                val id = call.parameters["orgID"]?.toInt() ?: -1
                val accessibilityID = params["accessibilityID"]?.toInt() ?: -1
                val categoriesID = params["categoriesID"]?.toInt() ?: -1

                if(id == -1){
                    call.respondHtml(HttpStatusCode.BadRequest){
                        body{
                            p{ +"Error, invalid orgID provided" }
                        }
                    }
                    return@post
                }
                if(accessibilityID == -1){
                    println("invalid accessID: ${accessibilityID}\nraw: ${call.parameters["accessibilityID"]}")
                    call.respondHtml(HttpStatusCode.BadRequest){
                        body{
                            p{ +"Error, invalid Accessibility Information ID received: ${accessibilityID}" }
                        }
                    }
                    return@post
                }
                if(categoriesID == -1){
                    call.respondHtml(HttpStatusCode.BadRequest){
                        body{
                            p{ +"Error, invalid Categories Information ID received " }
                        }
                    }
                    return@post
                }
                // generate a set of contact index numbers based on regex matching
                val contactIndices: Set<Int> =
                    params.names()
                        .mapNotNull { name ->
                            Regex("""contact(\d+)ID""").find(name)?.groupValues?.get(1)?.toInt()
                        }
                        .toSet()

                val results = mutableListOf<FlowContent.() -> Unit>()

                if(dbHandler.updateOrganizationTable( id,
                    params = mapOf(
                        "name" to params["name"],
                        "description" to params["description"],
                        "email" to params["email"],
                        "streetAddress" to params["streetAddress"],
                        "city" to params["city"],
                        "province" to params["province"],
                        "phoneNumber" to (params["phone"] ?: ""),
                        "socialMedia" to params["socialMedia"],
                        "website" to params["website"],
                        "queerOwned" to params["queerOwned"],
                        "queerInclusive" to params["queerInclusive"],
                        "otherInformation" to (params["otherInformation"] ?: ""),
                    ),
                    booleanMappings = mapOf(
                        "queerOwned" to OrganizationTable.queerOwned,
                        "queerInclusive" to OrganizationTable.queerInclusive
                    ),
                    stringMappings = mapOf(
                        "name" to OrganizationTable.name,
                        "description" to OrganizationTable.description,
                        "email" to OrganizationTable.email,
                        "streetAddress" to OrganizationTable.streetAddress,
                        "city" to OrganizationTable.city,
                        "province" to OrganizationTable.province,
                        "phoneNumber" to OrganizationTable.phoneNumber,
                        "socialMedia" to OrganizationTable.socialMedia,
                        "website" to OrganizationTable.website,
                        "otherInformation" to OrganizationTable.otherInformation
                    )
                )){results += { p { +"Organization Information Updated" } }}
                if(dbHandler.updateAccessibilityTable(accessibilityID,
                    params = mapOf(
                        "automaticDoors" to params["automaticDoors"],
                        "accessibleBathroom" to params["accessibleBathroom"],
                        "genderNeutralBathroom" to params["genderNeutralBathroom"],
                        "parking" to params["parking"],
                        "entrance" to params["entrance"]
                        ),
                    booleanMappings = mapOf(
                        "automaticDoors" to AccessibilityInformationTable.automaticDoors,
                        "accessibleBathroom" to AccessibilityInformationTable.accessibleBathroom,
                        "genderNeutralBathroom" to AccessibilityInformationTable.genderNeutralBathroom,
                        "parking" to AccessibilityInformationTable.parking,
                        "entrance" to AccessibilityInformationTable.entrance),
                )){results += { p { +"Accessibility Information Updated" } }}
                contactIndices.forEach {
                    if(dbHandler.updateContactInfo(
                        contactID = params["contact${it}ID"]!!.toInt(),
                        params = mapOf(
                            "name" to (params["contact${it}Name"] ?: "no name"),
                            "pronouns" to params["contact${it}Pronouns"],
                            "position" to params["contact${it}Position"],
                            "directEmail" to params["contact${it}DirectEmail"],
                            "directPhone" to params["contact${it}DirectPhone"],
                        ),
                        stringMappings = mapOf(
                            "name" to ContactTable.name,
                            "pronouns" to ContactTable.pronouns,
                            "position" to ContactTable.position,
                            "directEmail" to ContactTable.directEmail,
                            "directPhone" to ContactTable.directPhone
                        )
                    )) {results += { p { +"Contact $it Information Updated" } }}

                }
                if(dbHandler.updateCategoriesTable(
                        categoriesID = categoriesID,
                        params = mapOf(
                            "isEducation" to params["isEducation"],
                            "individual" to params["individual"],
                            "organization" to params["organization"],
                            "postSecondary" to params["postSecondary"],
                            "remoteOnline" to params["remoteOnline"],
                            "workshopsOrTraining" to params["workshopsOrTraining"],

                            "isHealthCare" to params["isHealthCare"],
                            "healthCentre" to params["healthCentre"],
                            "counselor" to params["counselor"],
                            "familyDoctor" to params["familyDoctor"],
                            "mental" to params["mental"],
                            "peerSupport" to params["peerSupport"],
                            "physical" to params["physical"],
                            "private" to params["private"],
                            "public" to params["public"],
                            "specialist" to params["specialist"],
                            "trans" to params["trans"],

                            "isHospitality" to params["isHospitality"],
                            "bar" to params["bar"],
                            "cafe" to params["cafe"],
                            "catering" to params["catering"],
                            "foodTruck" to params["foodTruck"],
                            "hotel" to params["hotel"],
                            "restaurant" to params["restaurant"],
                            "isRetail" to params["isRetail"],
                            "isAdult" to params["isAdult"],
                            "adultProducts" to params["adultProducts"],
                            "artist" to params["artist"],
                            "clothing" to params["clothing"],
                            "consultant" to params["consultant"],
                            "convenience" to params["convenience"],
                            "digitalServices" to params["digitalServices"],
                            "entertainment" to params["entertainment"],
                            "esthetics" to params["esthetics"],
                            "fitnessCentre" to params["fitnessCentre"],
                            "groceries" to params["groceries"],
                            "legal" to params["legal"],
                            "skilledTrades" to params["skilledTrades"],
                            "isOther" to params["isOther"],
                            "employment" to params["employment"],
                            "foodSecurity" to params["foodSecurity"],
                            "housing" to params["housing"],
                            "spiritual" to params["spiritual"],
                            "transportation" to params["transportation"],
                        ),
                        booleanMappings = mapOf(
                            "isEducation" to CategoriesTable.isEducation,
                            "individual" to CategoriesTable.individual,
                            "organization" to CategoriesTable.organization,
                            "postSecondary" to CategoriesTable.postSecondary,
                            "remoteOnline" to CategoriesTable.remoteOnline,
                            "workshopsOrTraining" to CategoriesTable.workshopsOrTraining,

                            "isHealthCare" to CategoriesTable.isHealthCare,
                            "healthCentre" to CategoriesTable.healthCentre,
                            "counselor" to CategoriesTable.counselor,
                            "familyDoctor" to CategoriesTable.familyDoctor,
                            "mental" to CategoriesTable.mental,
                            "peerSupport" to CategoriesTable.peerSupport,
                            "physical" to CategoriesTable.physical,
                            "private" to CategoriesTable.private,
                            "public" to CategoriesTable.public,
                            "specialist" to CategoriesTable.specialist,
                            "trans" to CategoriesTable.trans,
                            "isHospitality" to CategoriesTable.isHospitality,
                            "bar" to CategoriesTable.bar,
                            "cafe" to CategoriesTable.cafe,
                            "catering" to CategoriesTable.catering,
                            "foodTruck" to CategoriesTable.foodTruck,
                            "hotel" to CategoriesTable.hotel,
                            "restaurant" to CategoriesTable.restaurant,
                            "isRetail" to CategoriesTable.isRetail,
                            "isAdult" to CategoriesTable.isAdult,
                            "adultProducts" to CategoriesTable.adultProducts,
                            "artist" to CategoriesTable.artist,
                            "clothing" to CategoriesTable.clothing,
                            "consultant" to CategoriesTable.consultant,
                            "convenience" to CategoriesTable.convenience,
                            "digitalServices" to CategoriesTable.digitalServices,
                            "entertainment" to CategoriesTable.entertainment,
                            "esthetics" to CategoriesTable.esthetics,
                            "fitnessCentre" to CategoriesTable.fitnessCentre,
                            "groceries" to CategoriesTable.groceries,
                            "legal" to CategoriesTable.legal,
                            "skilledTrades" to CategoriesTable.skilledTrades,
                            "isOther" to CategoriesTable.isOther,
                            "employment" to CategoriesTable.employment,
                            "foodSecurity" to CategoriesTable.foodSecurity,
                            "housing" to CategoriesTable.housing,
                            "spiritual" to CategoriesTable.spiritual,
                            "transportation" to CategoriesTable.transportation,
                        )
                    )){results += { p { +"Categories Information Updated" } }}
                if(results.isEmpty()){results += { p { +"No changes were made" } }}
                call.respondHtml(HttpStatusCode.OK){
                    body{
                        p {
                            results.forEach {
                                it()
                            }
                        }
                    }
                }

                return@post
            }

            hx.get("/update/get-new-contact-form"){
                call.respondText { """
                        <fieldset class="update-form-contact">
                            <legend>New Contact</legend>
                            <label for="newName">Name:</label>
                            <input type="text" name="newName" id="newName">
                            <br/>
                            <label for="newPronouns">Pronouns:</label>
                            <input type="text" name="newPronouns" id="newPronouns">
                            <br/>
                            <label for="newPosition">Position:</label>
                            <input type="text" name="newPosition" id="newPosition">
                            <br/>
                            <label for="newEmail">Direct Email:</label>
                            <input type="text" name="newEmail" id="newEmail">
                            <br/>
                            <label for="newPhone">Direct Phone:</label>
                            <input type="text" name="newPhone" id="newPhone">                            
                        </fieldset>
                        <div id="contactFormContainer"></div>
                    """.trimIndent()
                }
                return@get
            }
        }
    }.start(wait = true)
}